!    -*- f90 -*-
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     https://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.

python module _speedup
    interface
        module surface
            use types, only: dp
            use curve, only: evaluate_curve_barycentric
            subroutine de_casteljau_one_round(num_nodes,dimension_,nodes,degree,lambda1,lambda2,lambda3,new_nodes)
                integer, optional,intent(hide),depend(nodes) :: num_nodes=size(nodes, 1)
                integer, optional,intent(hide),depend(nodes) :: dimension_=size(nodes, 2)
                real(kind=dp) dimension(num_nodes,dimension_),intent(in) :: nodes
                integer :: degree
                real(kind=dp) intent(in) :: lambda1
                real(kind=dp) intent(in) :: lambda2
                real(kind=dp) intent(in) :: lambda3
                real(kind=dp) dimension(num_nodes-degree-1,dimension_),intent(out),depend(num_nodes,degree,dimension_) :: new_nodes
            end subroutine de_casteljau_one_round
            subroutine evaluate_barycentric(num_nodes,dimension_,nodes,degree,lambda1,lambda2,lambda3,point)
                integer, optional,intent(hide),depend(nodes) :: num_nodes=size(nodes, 1)
                integer, optional,intent(hide),depend(nodes) :: dimension_=size(nodes, 2)
                real(kind=dp) dimension(num_nodes,dimension_),intent(in) :: nodes
                integer :: degree
                real(kind=dp) intent(in) :: lambda1
                real(kind=dp) intent(in) :: lambda2
                real(kind=dp) intent(in) :: lambda3
                real(kind=dp) dimension(1,dimension_),intent(out),depend(dimension_) :: point
            end subroutine evaluate_barycentric
            subroutine evaluate_barycentric_multi(num_nodes,nodes,degree,num_vals,param_vals,dimension_,evaluated)
                integer, optional,intent(hide),depend(nodes) :: num_nodes=size(nodes, 1)
                real(kind=dp) dimension(num_nodes,dimension_),intent(in) :: nodes
                integer :: degree
                integer, optional,intent(hide),depend(param_vals) :: num_vals=size(param_vals, 1)
                real(kind=dp) dimension(num_vals,3),intent(in) :: param_vals
                integer, optional,depend(nodes) :: dimension_=size(nodes, 2)
                real(kind=dp) dimension(num_vals,dimension_),intent(out),depend(num_vals,dimension_) :: evaluated
            end subroutine evaluate_barycentric_multi
            subroutine evaluate_cartesian_multi(num_nodes,nodes,degree,num_vals,param_vals,dimension_,evaluated)
                integer, optional,intent(hide),depend(nodes) :: num_nodes=size(nodes, 1)
                real(kind=dp) dimension(num_nodes,dimension_),intent(in) :: nodes
                integer :: degree
                integer, optional,intent(hide),depend(param_vals) :: num_vals=size(param_vals, 1)
                real(kind=dp) dimension(num_vals,2),intent(in) :: param_vals
                integer, optional,depend(nodes) :: dimension_=size(nodes, 2)
                real(kind=dp) dimension(num_vals,dimension_),intent(out),depend(num_vals,dimension_) :: evaluated
            end subroutine evaluate_cartesian_multi
            subroutine jacobian_both(num_nodes,dimension_,nodes,degree,new_nodes)
                integer, optional,intent(hide),depend(nodes) :: num_nodes=size(nodes, 1)
                integer, optional,depend(nodes) :: dimension_=size(nodes, 2)
                real(kind=dp) dimension(num_nodes,dimension_),intent(in) :: nodes
                integer :: degree
                real(kind=dp) dimension(num_nodes-degree-1,2 * dimension_),intent(out),depend(num_nodes,degree,dimension_) :: new_nodes
            end subroutine jacobian_both
            subroutine jacobian_det(num_nodes,nodes,degree,num_vals,param_vals,evaluated)
                integer, optional,intent(hide),depend(nodes) :: num_nodes=size(nodes, 1)
                real(kind=dp) dimension(num_nodes,2),intent(in) :: nodes
                integer :: degree
                integer, optional,intent(hide),depend(param_vals) :: num_vals=size(param_vals, 1)
                real(kind=dp) dimension(num_vals,2),intent(in) :: param_vals
                real(kind=dp) dimension(num_vals),intent(out),depend(num_vals) :: evaluated
            end subroutine jacobian_det
        end module surface
    end interface
end python module _speedup
